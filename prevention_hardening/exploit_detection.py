"""Zero-Click Exploit Detection Engine

Advanced detection system for zero-click exploits targeting:
- Messaging applications (iMessage, WhatsApp, Telegram, etc.)
- Email clients and attachments
- Web browsers and media processing
- System services and frameworks
"""

import os
import re
import json
import time
import hashlib
import threading
import subprocess
from typing import Dict, List, Optional, Set, Tuple, Any, Union
from dataclasses import dataclass, asdict
from enum import Enum
from pathlib import Path
from collections import defaultdict, deque
from loguru import logger

try:
    import psutil
except ImportError:
    psutil = None

try:
    import yara
except ImportError:
    yara = None


class ExploitType(Enum):
    """Types of zero-click exploits"""
    IMESSAGE_EXPLOIT = "imessage_exploit"
    WHATSAPP_EXPLOIT = "whatsapp_exploit"
    TELEGRAM_EXPLOIT = "telegram_exploit"
    EMAIL_EXPLOIT = "email_exploit"
    BROWSER_EXPLOIT = "browser_exploit"
    PDF_EXPLOIT = "pdf_exploit"
    IMAGE_EXPLOIT = "image_exploit"
    AUDIO_EXPLOIT = "audio_exploit"
    VIDEO_EXPLOIT = "video_exploit"
    FONT_EXPLOIT = "font_exploit"
    KERNEL_EXPLOIT = "kernel_exploit"
    FRAMEWORK_EXPLOIT = "framework_exploit"


class ExploitVector(Enum):
    """Exploit delivery vectors"""
    MESSAGE_ATTACHMENT = "message_attachment"
    EMAIL_ATTACHMENT = "email_attachment"
    WEB_CONTENT = "web_content"
    PUSH_NOTIFICATION = "push_notification"
    CALENDAR_INVITE = "calendar_invite"
    CONTACT_CARD = "contact_card"
    SHARED_FILE = "shared_file"
    NETWORK_PACKET = "network_packet"
    SYSTEM_SERVICE = "system_service"


class DetectionMethod(Enum):
    """Detection methods"""
    SIGNATURE_BASED = "signature_based"
    BEHAVIORAL_ANALYSIS = "behavioral_analysis"
    HEURISTIC_ANALYSIS = "heuristic_analysis"
    MEMORY_ANALYSIS = "memory_analysis"
    NETWORK_ANALYSIS = "network_analysis"
    FILE_ANALYSIS = "file_analysis"
    PROCESS_ANALYSIS = "process_analysis"
    ANOMALY_DETECTION = "anomaly_detection"


@dataclass
class ExploitSignature:
    """Zero-click exploit signature definition"""
    signature_id: str
    name: str
    description: str
    exploit_type: ExploitType
    exploit_vector: ExploitVector
    target_applications: List[str]
    target_versions: List[str]
    cve_ids: List[str]
    pattern: str
    pattern_type: str  # regex, yara, binary, etc.
    detection_method: DetectionMethod
    severity_score: float
    confidence_threshold: float
    false_positive_rate: float
    last_updated: str
    author: str
    references: List[str]
    mitigation_steps: List[str]


@dataclass
class ExploitDetection:
    """Exploit detection result"""
    detection_id: str
    signature_id: str
    exploit_type: ExploitType
    exploit_vector: ExploitVector
    target_application: str
    target_process_id: Optional[int]
    source_file: Optional[str]
    source_network: Optional[str]
    detection_timestamp: str
    confidence_score: float
    severity_score: float
    evidence: Dict[str, Any]
    memory_dump: Optional[str]
    network_capture: Optional[str]
    file_samples: List[str]
    process_tree: Dict[str, Any]
    system_state: Dict[str, Any]
    mitigation_applied: bool
    blocked: bool
    verified: bool


@dataclass
class BehavioralPattern:
    """Behavioral pattern for exploit detection"""
    pattern_id: str
    name: str
    description: str
    target_processes: List[str]
    suspicious_behaviors: List[str]
    memory_patterns: List[str]
    network_patterns: List[str]
    file_patterns: List[str]
    time_window: int  # seconds
    occurrence_threshold: int
    confidence_weight: float


@dataclass
class ProcessBehavior:
    """Process behavior tracking"""
    process_id: int
    process_name: str
    parent_pid: int
    command_line: str
    start_time: float
    cpu_usage_history: deque
    memory_usage_history: deque
    network_connections: List[Dict[str, Any]]
    file_operations: List[Dict[str, Any]]
    system_calls: List[Dict[str, Any]]
    child_processes: List[int]
    suspicious_activities: List[str]
    risk_score: float


class ZeroClickExploitDetector:
    """Advanced zero-click exploit detection engine"""
    
    def __init__(self):
        self.detection_active = False
        self.monitoring_threads: List[threading.Thread] = []
        
        # Detection storage
        self.exploit_detections: List[ExploitDetection] = []
        self.process_behaviors: Dict[int, ProcessBehavior] = {}
        
        # Signatures and patterns
        self.exploit_signatures: Dict[str, ExploitSignature] = {}
        self.behavioral_patterns: Dict[str, BehavioralPattern] = {}
        self.yara_rules: Optional[Any] = None
        
        # Monitoring data
        self.monitored_processes: Set[int] = set()
        self.suspicious_files: Set[str] = set()
        self.network_anomalies: List[Dict[str, Any]] = []
        
        # Detection statistics
        self.detection_stats = {
            'total_detections': 0,
            'blocked_exploits': 0,
            'false_positives': 0,
            'verified_exploits': 0
        }
        
        # Initialize detection components
        self._initialize_exploit_signatures()
        self._initialize_behavioral_patterns()
        self._initialize_yara_rules()
        
        logger.info("ZeroClickExploitDetector initialized")
    
    def _initialize_exploit_signatures(self) -> None:
        """Initialize comprehensive exploit signatures"""
        signatures = [
            # Pegasus/NSO Group exploits
            ExploitSignature(
                signature_id="pegasus_imessage_2021",
                name="Pegasus iMessage Zero-Click (FORCEDENTRY)",
                description="NSO Group Pegasus exploit targeting iMessage via malformed PDF/GIF",
                exploit_type=ExploitType.IMESSAGE_EXPLOIT,
                exploit_vector=ExploitVector.MESSAGE_ATTACHMENT,
                target_applications=["com.apple.MobileSMS", "Messages"],
                target_versions=["iOS 14.x", "iOS 15.0-15.0.1"],
                cve_ids=["CVE-2021-30860"],
                pattern=r".*\.pdf.*<<\/JavaScript.*eval\(.*\).*>>|.*\.gif.*JFIF.*\x00\x00\x00\x00.*",
                pattern_type="regex",
                detection_method=DetectionMethod.SIGNATURE_BASED,
                severity_score=10.0,
                confidence_threshold=0.9,
                false_positive_rate=0.01,
                last_updated="2021-09-13",
                author="Citizen Lab",
                references=[
                    "https://citizenlab.ca/2021/09/forcedentry-nso-group-imessage-zero-click-exploit/"
                ],
                mitigation_steps=[
                    "Update to iOS 15.0.2 or later",
                    "Disable iMessage if not needed",
                    "Enable Lockdown Mode (iOS 16+)"
                ]
            ),
            
            # WhatsApp exploits
            ExploitSignature(
                signature_id="whatsapp_voip_2019",
                name="WhatsApp VoIP Buffer Overflow",
                description="Buffer overflow in WhatsApp VoIP call handling",
                exploit_type=ExploitType.WHATSAPP_EXPLOIT,
                exploit_vector=ExploitVector.NETWORK_PACKET,
                target_applications=["com.whatsapp.WhatsApp", "WhatsApp"],
                target_versions=["2.19.134 and earlier"],
                cve_ids=["CVE-2019-3568"],
                pattern=r"WhatsApp.*VoIP.*call.*buffer.*overflow",
                pattern_type="regex",
                detection_method=DetectionMethod.BEHAVIORAL_ANALYSIS,
                severity_score=9.0,
                confidence_threshold=0.8,
                false_positive_rate=0.05,
                last_updated="2019-05-13",
                author="WhatsApp Security Team",
                references=[
                    "https://www.whatsapp.com/security/advisories/2019/"
                ],
                mitigation_steps=[
                    "Update WhatsApp to latest version",
                    "Restart WhatsApp application"
                ]
            ),
            
            # Telegram exploits
            ExploitSignature(
                signature_id="telegram_media_2020",
                name="Telegram Media Processing Exploit",
                description="Exploit in Telegram media file processing",
                exploit_type=ExploitType.TELEGRAM_EXPLOIT,
                exploit_vector=ExploitVector.MESSAGE_ATTACHMENT,
                target_applications=["org.telegram.desktop", "Telegram"],
                target_versions=["2.1.13 and earlier"],
                cve_ids=["CVE-2020-17448"],
                pattern=r"telegram.*media.*processing.*exploit",
                pattern_type="regex",
                detection_method=DetectionMethod.FILE_ANALYSIS,
                severity_score=8.5,
                confidence_threshold=0.75,
                false_positive_rate=0.03,
                last_updated="2020-08-11",
                author="Telegram Security Team",
                references=[
                    "https://telegram.org/blog/security-update"
                ],
                mitigation_steps=[
                    "Update Telegram to latest version",
                    "Avoid opening suspicious media files"
                ]
            ),
            
            # Browser exploits
            ExploitSignature(
                signature_id="safari_webkit_2021",
                name="Safari WebKit Zero-Day",
                description="WebKit zero-day exploit targeting Safari",
                exploit_type=ExploitType.BROWSER_EXPLOIT,
                exploit_vector=ExploitVector.WEB_CONTENT,
                target_applications=["com.apple.Safari", "Safari"],
                target_versions=["Safari 14.x"],
                cve_ids=["CVE-2021-1879", "CVE-2021-1870"],
                pattern=r"webkit.*exploit.*safari.*zero.*day",
                pattern_type="regex",
                detection_method=DetectionMethod.MEMORY_ANALYSIS,
                severity_score=9.5,
                confidence_threshold=0.85,
                false_positive_rate=0.02,
                last_updated="2021-03-26",
                author="Google Project Zero",
                references=[
                    "https://googleprojectzero.blogspot.com/2021/01/in-wild-ios-exploit-chain-1.html"
                ],
                mitigation_steps=[
                    "Update Safari and iOS/macOS",
                    "Enable Enhanced Tracking Protection"
                ]
            ),
            
            # PDF exploits
            ExploitSignature(
                signature_id="pdf_javascript_exploit",
                name="PDF JavaScript Exploit",
                description="Malicious JavaScript in PDF files",
                exploit_type=ExploitType.PDF_EXPLOIT,
                exploit_vector=ExploitVector.EMAIL_ATTACHMENT,
                target_applications=["Preview", "Adobe Reader", "PDF viewers"],
                target_versions=["Various"],
                cve_ids=["CVE-2021-28550"],
                pattern=r".*\.pdf.*<<\/JavaScript.*eval\(.*\).*>>",
                pattern_type="regex",
                detection_method=DetectionMethod.FILE_ANALYSIS,
                severity_score=8.0,
                confidence_threshold=0.9,
                false_positive_rate=0.01,
                last_updated="2021-04-15",
                author="Security Researcher",
                references=[
                    "https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2021-28550"
                ],
                mitigation_steps=[
                    "Disable JavaScript in PDF viewers",
                    "Use sandboxed PDF viewers"
                ]
            ),
            
            # Image exploits
            ExploitSignature(
                signature_id="image_processing_exploit",
                name="Image Processing Buffer Overflow",
                description="Buffer overflow in image processing libraries",
                exploit_type=ExploitType.IMAGE_EXPLOIT,
                exploit_vector=ExploitVector.MESSAGE_ATTACHMENT,
                target_applications=["ImageIO", "CoreGraphics", "Image viewers"],
                target_versions=["Various"],
                cve_ids=["CVE-2021-30713"],
                pattern=r".*\.(jpg|jpeg|png|gif|tiff).*buffer.*overflow",
                pattern_type="regex",
                detection_method=DetectionMethod.MEMORY_ANALYSIS,
                severity_score=8.5,
                confidence_threshold=0.8,
                false_positive_rate=0.04,
                last_updated="2021-05-24",
                author="Apple Security Team",
                references=[
                    "https://support.apple.com/en-us/HT212528"
                ],
                mitigation_steps=[
                    "Update system image processing libraries",
                    "Use secure image viewers"
                ]
            )
        ]
        
        for signature in signatures:
            self.exploit_signatures[signature.signature_id] = signature
        
        logger.info(f"Loaded {len(self.exploit_signatures)} exploit signatures")
    
    def _initialize_behavioral_patterns(self) -> None:
        """Initialize behavioral detection patterns"""
        patterns = [
            BehavioralPattern(
                pattern_id="messaging_app_anomaly",
                name="Messaging App Behavioral Anomaly",
                description="Unusual behavior in messaging applications",
                target_processes=["Messages", "WhatsApp", "Telegram", "Signal"],
                suspicious_behaviors=[
                    "excessive_memory_usage",
                    "unusual_network_activity",
                    "unexpected_file_creation",
                    "privilege_escalation_attempt",
                    "system_call_anomaly"
                ],
                memory_patterns=[
                    "heap_spray_pattern",
                    "rop_chain_pattern",
                    "shellcode_pattern"
                ],
                network_patterns=[
                    "c2_communication",
                    "data_exfiltration",
                    "unusual_dns_queries"
                ],
                file_patterns=[
                    "temp_file_creation",
                    "payload_dropping",
                    "persistence_mechanism"
                ],
                time_window=300,  # 5 minutes
                occurrence_threshold=3,
                confidence_weight=0.8
            ),
            
            BehavioralPattern(
                pattern_id="browser_exploit_behavior",
                name="Browser Exploit Behavior",
                description="Behavioral patterns indicating browser exploitation",
                target_processes=["Safari", "Chrome", "Firefox", "Edge"],
                suspicious_behaviors=[
                    "renderer_process_crash",
                    "unexpected_process_spawn",
                    "sandbox_escape_attempt",
                    "jit_spray_pattern"
                ],
                memory_patterns=[
                    "use_after_free_pattern",
                    "type_confusion_pattern",
                    "bounds_check_bypass"
                ],
                network_patterns=[
                    "malicious_javascript_download",
                    "exploit_kit_communication"
                ],
                file_patterns=[
                    "browser_cache_manipulation",
                    "extension_injection"
                ],
                time_window=180,  # 3 minutes
                occurrence_threshold=2,
                confidence_weight=0.85
            )
        ]
        
        for pattern in patterns:
            self.behavioral_patterns[pattern.pattern_id] = pattern
        
        logger.info(f"Loaded {len(self.behavioral_patterns)} behavioral patterns")
    
    def _initialize_yara_rules(self) -> None:
        """Initialize YARA rules for exploit detection"""
        if not yara:
            logger.warning("YARA not available, signature-based detection limited")
            return
        
        yara_rules_content = """
        rule Pegasus_iMessage_Exploit {
            meta:
                description = "Detects Pegasus iMessage exploit patterns"
                author = "PegaSpy"
                date = "2021-09-13"
                
            strings:
                $pdf_js = "<<\/JavaScript" nocase
                $eval_pattern = "eval(" nocase
                $gif_header = { 47 49 46 38 }
                $jfif_marker = "JFIF"
                $null_bytes = { 00 00 00 00 }
                
            condition:
                ($pdf_js and $eval_pattern) or
                ($gif_header and $jfif_marker and $null_bytes)
        }
        
        rule WhatsApp_VoIP_Exploit {
            meta:
                description = "Detects WhatsApp VoIP exploit patterns"
                author = "PegaSpy"
                date = "2019-05-13"
                
            strings:
                $voip_call = "VoIP call" nocase
                $buffer_overflow = "buffer overflow" nocase
                $whatsapp = "WhatsApp" nocase
                
            condition:
                $whatsapp and ($voip_call or $buffer_overflow)
        }
        
        rule Generic_Zero_Click_Exploit {
            meta:
                description = "Generic zero-click exploit patterns"
                author = "PegaSpy"
                date = "2021-01-01"
                
            strings:
                $shellcode1 = { 48 31 c0 48 31 db 48 31 c9 48 31 d2 }
                $shellcode2 = { 31 c0 50 68 2f 2f 73 68 68 2f 62 69 6e }
                $rop_gadget = { 48 89 e6 48 c7 c0 3b 00 00 00 0f 05 }
                $heap_spray = { 41 41 41 41 41 41 41 41 }
                
            condition:
                any of ($shellcode*) or $rop_gadget or #heap_spray > 100
        }
        """
        
        try:
            self.yara_rules = yara.compile(source=yara_rules_content)
            logger.info("YARA rules compiled successfully")
        except Exception as e:
            logger.error(f"Failed to compile YARA rules: {e}")
    
    def start_detection(self) -> None:
        """Start zero-click exploit detection"""
        if self.detection_active:
            logger.warning("Exploit detection already active")
            return
        
        self.detection_active = True
        
        # Start monitoring threads
        threads = [
            threading.Thread(target=self._monitor_processes, daemon=True),
            threading.Thread(target=self._monitor_files, daemon=True),
            threading.Thread(target=self._monitor_network, daemon=True),
            threading.Thread(target=self._monitor_memory, daemon=True),
            threading.Thread(target=self._analyze_behaviors, daemon=True)
        ]
        
        for thread in threads:
            thread.start()
            self.monitoring_threads.append(thread)
        
        logger.info("Zero-click exploit detection started")
    
    def stop_detection(self) -> None:
        """Stop zero-click exploit detection"""
        self.detection_active = False
        
        # Wait for threads to finish
        for thread in self.monitoring_threads:
            thread.join(timeout=5)
        
        self.monitoring_threads.clear()
        logger.info("Zero-click exploit detection stopped")
    
    def _monitor_processes(self) -> None:
        """Monitor processes for suspicious behavior"""
        while self.detection_active:
            try:
                if psutil:
                    self._scan_running_processes()
                time.sleep(5)  # Check every 5 seconds
            except Exception as e:
                logger.error(f"Error in process monitoring: {e}")
                time.sleep(10)
    
    def _scan_running_processes(self) -> None:
        """Scan running processes for suspicious activity"""
        target_processes = [
            "Messages", "WhatsApp", "Telegram", "Signal", "Viber", "WeChat",
            "Safari", "Chrome", "Firefox", "Edge", "Mail", "Preview"
        ]
        
        try:
            for process in psutil.process_iter(['pid', 'name', 'cmdline', 'memory_info', 'cpu_percent']):
                if process.info['name'] in target_processes:
                    pid = process.info['pid']
                    
                    # Initialize or update process behavior tracking
                    if pid not in self.process_behaviors:
                        self.process_behaviors[pid] = ProcessBehavior(
                            process_id=pid,
                            process_name=process.info['name'],
                            parent_pid=process.ppid() if hasattr(process, 'ppid') else 0,
                            command_line=' '.join(process.info['cmdline'] or []),
                            start_time=time.time(),
                            cpu_usage_history=deque(maxlen=60),  # Last 60 measurements
                            memory_usage_history=deque(maxlen=60),
                            network_connections=[],
                            file_operations=[],
                            system_calls=[],
                            child_processes=[],
                            suspicious_activities=[],
                            risk_score=0.0
                        )
                    
                    behavior = self.process_behaviors[pid]
                    
                    # Update resource usage
                    memory_mb = process.info['memory_info'].rss / 1024 / 1024
                    cpu_percent = process.info['cpu_percent']
                    
                    behavior.cpu_usage_history.append(cpu_percent)
                    behavior.memory_usage_history.append(memory_mb)
                    
                    # Analyze for suspicious patterns
                    self._analyze_process_behavior(behavior)
                    
        except Exception as e:
            logger.error(f"Error scanning processes: {e}")
    
    def _analyze_process_behavior(self, behavior: ProcessBehavior) -> None:
        """Analyze process behavior for exploit indicators"""
        suspicious_activities = []
        risk_score = 0.0
        
        # Check memory usage anomalies
        if len(behavior.memory_usage_history) >= 10:
            recent_memory = list(behavior.memory_usage_history)[-10:]
            avg_memory = sum(recent_memory) / len(recent_memory)
            
            # Sudden memory spike (possible heap spray)
            if avg_memory > 500:  # MB
                suspicious_activities.append("excessive_memory_usage")
                risk_score += 30.0
            
            # Memory usage pattern analysis
            memory_variance = sum((x - avg_memory) ** 2 for x in recent_memory) / len(recent_memory)
            if memory_variance > 10000:  # High variance
                suspicious_activities.append("memory_usage_anomaly")
                risk_score += 20.0
        
        # Check CPU usage anomalies
        if len(behavior.cpu_usage_history) >= 10:
            recent_cpu = list(behavior.cpu_usage_history)[-10:]
            avg_cpu = sum(recent_cpu) / len(recent_cpu)
            
            if avg_cpu > 80:  # High CPU usage
                suspicious_activities.append("excessive_cpu_usage")
                risk_score += 25.0
        
        # Update behavior tracking
        behavior.suspicious_activities.extend(suspicious_activities)
        behavior.risk_score = min(risk_score, 100.0)
        
        # Create detection if risk score is high
        if risk_score > 50.0:
            self._create_exploit_detection(
                signature_id="behavioral_anomaly",
                exploit_type=ExploitType.IMESSAGE_EXPLOIT,  # Default, could be refined
                exploit_vector=ExploitVector.MESSAGE_ATTACHMENT,
                target_application=behavior.process_name,
                target_process_id=behavior.process_id,
                confidence_score=risk_score / 100.0,
                evidence={
                    "suspicious_activities": suspicious_activities,
                    "memory_usage": list(behavior.memory_usage_history),
                    "cpu_usage": list(behavior.cpu_usage_history),
                    "risk_score": risk_score
                }
            )
    
    def _monitor_files(self) -> None:
        """Monitor file system for exploit artifacts"""
        while self.detection_active:
            try:
                self._scan_suspicious_files()
                time.sleep(10)  # Check every 10 seconds
            except Exception as e:
                logger.error(f"Error in file monitoring: {e}")
                time.sleep(30)
    
    def _scan_suspicious_files(self) -> None:
        """Scan for suspicious files that might contain exploits"""
        suspicious_paths = [
            os.path.expanduser("~/Downloads"),
            os.path.expanduser("~/Desktop"),
            os.path.expanduser("~/Documents"),
            "/tmp",
            "/var/tmp"
        ]
        
        for path in suspicious_paths:
            if os.path.exists(path):
                try:
                    for root, dirs, files in os.walk(path):
                        for file in files:
                            file_path = os.path.join(root, file)
                            if self._is_potentially_malicious_file(file_path):
                                self._analyze_file_for_exploits(file_path)
                except Exception as e:
                    logger.error(f"Error scanning {path}: {e}")
    
    def _is_potentially_malicious_file(self, file_path: str) -> bool:
        """Check if file is potentially malicious"""
        try:
            # Check file extension
            suspicious_extensions = [
                '.pdf', '.gif', '.jpg', '.jpeg', '.png', '.tiff', '.bmp',
                '.mp4', '.mov', '.avi', '.mp3', '.wav', '.m4a',
                '.doc', '.docx', '.xls', '.xlsx', '.ppt', '.pptx',
                '.zip', '.rar', '.7z', '.tar', '.gz'
            ]
            
            file_ext = os.path.splitext(file_path)[1].lower()
            if file_ext not in suspicious_extensions:
                return False
            
            # Check file age (recently created/modified)
            stat = os.stat(file_path)
            if time.time() - max(stat.st_ctime, stat.st_mtime) > 3600:  # Older than 1 hour
                return False
            
            # Check file size (unusually large or small)
            file_size = stat.st_size
            if file_size < 1024 or file_size > 100 * 1024 * 1024:  # < 1KB or > 100MB
                return True
            
            return True
            
        except Exception:
            return False
    
    def _analyze_file_for_exploits(self, file_path: str) -> None:
        """Analyze file for exploit signatures"""
        try:
            # Read file content
            with open(file_path, 'rb') as f:
                content = f.read(1024 * 1024)  # Read first 1MB
            
            # Check against exploit signatures
            for signature in self.exploit_signatures.values():
                if self._check_signature_match(content, signature):
                    self._create_exploit_detection(
                        signature_id=signature.signature_id,
                        exploit_type=signature.exploit_type,
                        exploit_vector=signature.exploit_vector,
                        target_application="File System",
                        source_file=file_path,
                        confidence_score=0.9,
                        evidence={
                            "file_path": file_path,
                            "file_size": len(content),
                            "signature_match": signature.name,
                            "cve_ids": signature.cve_ids
                        }
                    )
            
            # YARA rule scanning
            if self.yara_rules:
                matches = self.yara_rules.match(data=content)
                for match in matches:
                    self._create_exploit_detection(
                        signature_id=f"yara_{match.rule}",
                        exploit_type=ExploitType.IMESSAGE_EXPLOIT,  # Default
                        exploit_vector=ExploitVector.MESSAGE_ATTACHMENT,
                        target_application="File System",
                        source_file=file_path,
                        confidence_score=0.95,
                        evidence={
                            "yara_rule": match.rule,
                            "yara_matches": [str(m) for m in match.strings],
                            "file_path": file_path
                        }
                    )
                    
        except Exception as e:
            logger.error(f"Error analyzing file {file_path}: {e}")
    
    def _check_signature_match(self, content: bytes, signature: ExploitSignature) -> bool:
        """Check if content matches exploit signature"""
        try:
            if signature.pattern_type == "regex":
                return bool(re.search(signature.pattern.encode(), content, re.IGNORECASE))
            elif signature.pattern_type == "binary":
                return signature.pattern.encode() in content
            else:
                return False
        except Exception:
            return False
    
    def _monitor_network(self) -> None:
        """Monitor network activity for exploit indicators"""
        while self.detection_active:
            try:
                self._analyze_network_connections()
                time.sleep(15)  # Check every 15 seconds
            except Exception as e:
                logger.error(f"Error in network monitoring: {e}")
                time.sleep(30)
    
    def _analyze_network_connections(self) -> None:
        """Analyze network connections for suspicious activity"""
        if not psutil:
            return
        
        try:
            for conn in psutil.net_connections(kind='inet'):
                if conn.status == 'ESTABLISHED' and conn.raddr:
                    # Check for suspicious connections
                    if self._is_suspicious_connection(conn):
                        self._create_exploit_detection(
                            signature_id="suspicious_network_connection",
                            exploit_type=ExploitType.NETWORK_ANOMALY,
                            exploit_vector=ExploitVector.NETWORK_PACKET,
                            target_application="Network",
                            source_network=f"{conn.raddr.ip}:{conn.raddr.port}",
                            confidence_score=0.7,
                            evidence={
                                "local_address": f"{conn.laddr.ip}:{conn.laddr.port}",
                                "remote_address": f"{conn.raddr.ip}:{conn.raddr.port}",
                                "connection_status": conn.status,
                                "process_id": conn.pid
                            }
                        )
        except Exception as e:
            logger.error(f"Error analyzing network connections: {e}")
    
    def _is_suspicious_connection(self, conn) -> bool:
        """Check if network connection is suspicious"""
        # Check for connections to suspicious IPs/ports
        suspicious_ports = [4444, 5555, 6666, 7777, 8888, 9999]  # Common backdoor ports
        
        if conn.raddr.port in suspicious_ports:
            return True
        
        # Check for connections to private IP ranges from public processes
        remote_ip = conn.raddr.ip
        if remote_ip.startswith(('10.', '172.', '192.168.')):
            return False  # Internal network, likely safe
        
        # Additional checks could include:
        # - Geolocation of IP
        # - Reputation databases
        # - Unusual connection patterns
        
        return False
    
    def _monitor_memory(self) -> None:
        """Monitor memory for exploit patterns"""
        while self.detection_active:
            try:
                self._scan_memory_patterns()
                time.sleep(20)  # Check every 20 seconds
            except Exception as e:
                logger.error(f"Error in memory monitoring: {e}")
                time.sleep(60)
    
    def _scan_memory_patterns(self) -> None:
        """Scan memory for exploit patterns"""
        # This would require more advanced memory analysis tools
        # For now, we'll focus on process-level indicators
        pass
    
    def _analyze_behaviors(self) -> None:
        """Analyze collected behaviors for exploit patterns"""
        while self.detection_active:
            try:
                self._correlate_behavioral_patterns()
                time.sleep(30)  # Analyze every 30 seconds
            except Exception as e:
                logger.error(f"Error in behavior analysis: {e}")
                time.sleep(60)
    
    def _correlate_behavioral_patterns(self) -> None:
        """Correlate behavioral patterns across different data sources"""
        for pattern in self.behavioral_patterns.values():
            matching_processes = []
            
            # Find processes matching the pattern
            for pid, behavior in self.process_behaviors.items():
                if behavior.process_name in pattern.target_processes:
                    # Check if behavior matches pattern criteria
                    if self._behavior_matches_pattern(behavior, pattern):
                        matching_processes.append(behavior)
            
            # If enough matching processes found, create detection
            if len(matching_processes) >= pattern.occurrence_threshold:
                self._create_behavioral_detection(pattern, matching_processes)
    
    def _behavior_matches_pattern(self, behavior: ProcessBehavior, pattern: BehavioralPattern) -> bool:
        """Check if behavior matches the given pattern"""
        matches = 0
        
        # Check suspicious behaviors
        for suspicious_behavior in pattern.suspicious_behaviors:
            if suspicious_behavior in behavior.suspicious_activities:
                matches += 1
        
        # Check if enough behaviors match
        return matches >= len(pattern.suspicious_behaviors) // 2
    
    def _create_behavioral_detection(self, pattern: BehavioralPattern, 
                                   matching_processes: List[ProcessBehavior]) -> None:
        """Create detection based on behavioral pattern"""
        self._create_exploit_detection(
            signature_id=pattern.pattern_id,
            exploit_type=ExploitType.IMESSAGE_EXPLOIT,  # Default
            exploit_vector=ExploitVector.MESSAGE_ATTACHMENT,
            target_application="Multiple Processes",
            confidence_score=pattern.confidence_weight,
            evidence={
                "pattern_name": pattern.name,
                "matching_processes": [p.process_name for p in matching_processes],
                "process_ids": [p.process_id for p in matching_processes],
                "behavioral_indicators": pattern.suspicious_behaviors
            }
        )
    
    def _create_exploit_detection(self, signature_id: str, exploit_type: ExploitType,
                                exploit_vector: ExploitVector, target_application: str,
                                target_process_id: Optional[int] = None,
                                source_file: Optional[str] = None,
                                source_network: Optional[str] = None,
                                confidence_score: float = 0.8,
                                evidence: Dict[str, Any] = None) -> None:
        """Create and store exploit detection"""
        detection_id = f"exploit_{int(time.time())}_{hash(signature_id + target_application) % 10000}"
        
        # Get signature details
        signature = self.exploit_signatures.get(signature_id)
        severity_score = signature.severity_score if signature else 7.0
        
        detection = ExploitDetection(
            detection_id=detection_id,
            signature_id=signature_id,
            exploit_type=exploit_type,
            exploit_vector=exploit_vector,
            target_application=target_application,
            target_process_id=target_process_id,
            source_file=source_file,
            source_network=source_network,
            detection_timestamp=time.strftime('%Y-%m-%d %H:%M:%S'),
            confidence_score=confidence_score,
            severity_score=severity_score,
            evidence=evidence or {},
            memory_dump=None,
            network_capture=None,
            file_samples=[source_file] if source_file else [],
            process_tree={},
            system_state={},
            mitigation_applied=False,
            blocked=False,
            verified=False
        )
        
        self.exploit_detections.append(detection)
        self.detection_stats['total_detections'] += 1
        
        logger.critical(f"ðŸš¨ ZERO-CLICK EXPLOIT DETECTED: {signature_id} targeting {target_application} (Confidence: {confidence_score:.2f})")
        
        # Auto-mitigation for high-confidence detections
        if confidence_score > 0.9 and severity_score > 8.0:
            self._apply_automatic_mitigation(detection)
    
    def _apply_automatic_mitigation(self, detection: ExploitDetection) -> None:
        """Apply automatic mitigation for high-confidence detections"""
        try:
            # Kill suspicious process if identified
            if detection.target_process_id:
                try:
                    process = psutil.Process(detection.target_process_id)
                    process.terminate()
                    detection.mitigation_applied = True
                    detection.blocked = True
                    self.detection_stats['blocked_exploits'] += 1
                    logger.info(f"Terminated suspicious process {detection.target_process_id}")
                except Exception as e:
                    logger.error(f"Failed to terminate process: {e}")
            
            # Quarantine suspicious file
            if detection.source_file and os.path.exists(detection.source_file):
                try:
                    quarantine_dir = "/tmp/pegaspy_quarantine"
                    os.makedirs(quarantine_dir, exist_ok=True)
                    quarantine_path = os.path.join(quarantine_dir, os.path.basename(detection.source_file))
                    os.rename(detection.source_file, quarantine_path)
                    detection.mitigation_applied = True
                    logger.info(f"Quarantined suspicious file: {detection.source_file}")
                except Exception as e:
                    logger.error(f"Failed to quarantine file: {e}")
                    
        except Exception as e:
            logger.error(f"Error applying mitigation: {e}")
    
    def get_detection_summary(self) -> Dict[str, Any]:
        """Get summary of exploit detections"""
        return {
            'total_detections': len(self.exploit_detections),
            'blocked_exploits': sum(1 for d in self.exploit_detections if d.blocked),
            'verified_exploits': sum(1 for d in self.exploit_detections if d.verified),
            'high_confidence_detections': sum(1 for d in self.exploit_detections if d.confidence_score > 0.8),
            'exploit_types': list(set(d.exploit_type.value for d in self.exploit_detections)),
            'target_applications': list(set(d.target_application for d in self.exploit_detections)),
            'detection_stats': self.detection_stats,
            'monitoring_status': 'active' if self.detection_active else 'inactive'
        }
    
    def export_detections(self, filename: str) -> None:
        """Export detections to JSON file"""
        try:
            detections_data = [asdict(detection) for detection in self.exploit_detections]
            with open(filename, 'w') as f:
                json.dump({
                    'export_timestamp': time.strftime('%Y-%m-%d %H:%M:%S'),
                    'total_detections': len(detections_data),
                    'detection_summary': self.get_detection_summary(),
                    'detections': detections_data
                }, f, indent=2, default=str)
            logger.info(f"Exported {len(detections_data)} detections to {filename}")
        except Exception as e:
            logger.error(f"Failed to export detections: {e}")