#!/usr/bin/env python3
"""
Zero-Click Exploits Demonstration

This script demonstrates PegaSpy's advanced zero-click exploit capabilities.
Zero-click exploits are sophisticated attacks that execute without any user
interaction, embedding malicious payloads in data that the operating system
automatically processes.

FEATURES DEMONSTRATED:
- Image-based exploits (JPEG/PNG parser vulnerabilities)
- Push notification exploits (APNs/FCM payload injection)
- Wallet pass exploits (Apple Wallet/Google Pay)
- VoIP call invite exploits (WebRTC/SIP)
- PDF JavaScript exploits
- Bluetooth beacon exploits
- Font parsing exploits
- Audio/Video codec exploits
- Real-time detection and analysis
- Comprehensive threat assessment

WARNING: This is for educational and security research purposes only.
"""

import os
import sys
import json
import asyncio
import logging
from datetime import datetime
from typing import List, Dict, Any

# Add the project root to the path
sys.path.append(os.path.dirname(os.path.abspath(__file__)))

from zero_click_exploits.zero_click_detector import (
    ZeroClickDetector, ThreatLevel, ExploitVector, DetectionResult
)
from zero_click_exploits.exploit_framework import (
    ZeroClickExploitFramework, ExploitType, TargetPlatform, ExploitStatus
)

class ZeroClickDemo:
    """Demonstration of zero-click exploit capabilities"""
    
    def __init__(self):
        self.logger = self._setup_logging()
        self.detector = ZeroClickDetector()
        self.framework = ZeroClickExploitFramework()
        self.demo_dir = "/tmp/pegaspy_zero_click_demo"
        self.results = []
        
    def _setup_logging(self) -> logging.Logger:
        """Setup logging for the demonstration"""
        logging.basicConfig(
            level=logging.INFO,
            format='%(asctime)s - %(levelname)s - %(message)s',
            handlers=[
                logging.StreamHandler(),
                logging.FileHandler('zero_click_demo.log')
            ]
        )
        return logging.getLogger(__name__)
    
    def print_banner(self):
        """Print demonstration banner"""
        banner = """
╔══════════════════════════════════════════════════════════════════════════════╗
║                        🕷️  PEGASPY ZERO-CLICK EXPLOITS 🕷️                    ║
║                                                                              ║
║  Advanced Zero-Click Exploit Framework & Detection System                   ║
║  ═══════════════════════════════════════════════════════                   ║
║                                                                              ║
║  Zero-click exploits execute without user interaction by embedding          ║
║  malicious payloads in data that the OS automatically processes:            ║
║                                                                              ║
║  📱 Image Files      - JPEG/PNG parser vulnerabilities                      ║
║  📲 Push Notifications - APNs/FCM payload injection                         ║
║  💳 Wallet Passes    - Apple Wallet/Google Pay exploits                    ║
║  📞 VoIP Invites     - WebRTC/SIP call processing                          ║
║  📄 PDF Documents    - JavaScript auto-execution                           ║
║  📡 Bluetooth Beacons - Proximity-based attacks                            ║
║  🔤 Font Files       - Font rendering exploits                             ║
║  🎵 Audio/Video      - Codec vulnerabilities                               ║
║                                                                              ║
║  ⚠️  FOR SECURITY RESEARCH AND DEFENSE VALIDATION ONLY ⚠️                   ║
╚══════════════════════════════════════════════════════════════════════════════╝
        """
        print(banner)
    
    async def setup_demo_environment(self):
        """Setup demonstration environment"""
        self.logger.info("🔧 Setting up zero-click exploit demonstration environment...")
        
        # Create demo directory
        os.makedirs(self.demo_dir, exist_ok=True)
        
        # Create subdirectories for different exploit types
        subdirs = [
            'images', 'notifications', 'wallet_passes', 'voip_invites',
            'pdf_documents', 'bluetooth_beacons', 'fonts', 'audio', 'video'
        ]
        
        for subdir in subdirs:
            os.makedirs(os.path.join(self.demo_dir, subdir), exist_ok=True)
        
        self.logger.info(f"✅ Demo environment created at: {self.demo_dir}")
    
    async def demonstrate_image_exploits(self):
        """Demonstrate image-based zero-click exploits"""
        self.logger.info("\n📱 DEMONSTRATING IMAGE-BASED ZERO-CLICK EXPLOITS")
        self.logger.info("═" * 60)
        
        # Create malicious JPEG for iOS
        ios_jpeg_exploit = self.framework.create_exploit(
            ExploitType.IMAGE_PARSER,
            TargetPlatform.IOS,
            {'format': 'jpeg'}
        )
        
        # Create malicious PNG for Android
        android_png_exploit = self.framework.create_exploit(
            ExploitType.IMAGE_PARSER,
            TargetPlatform.ANDROID,
            {'format': 'png'}
        )
        
        # Export exploits to files
        jpeg_path = os.path.join(self.demo_dir, 'images', 'malicious_photo.jpg')
        png_path = os.path.join(self.demo_dir, 'images', 'innocent_image.png')
        
        self.framework.export_exploit(ios_jpeg_exploit, jpeg_path)
        self.framework.export_exploit(android_png_exploit, png_path)
        
        self.logger.info(f"📸 Created malicious JPEG: {jpeg_path}")
        self.logger.info(f"🖼️  Created malicious PNG: {png_path}")
        
        # Scan the created files
        jpeg_result = await self.detector.scan_file(jpeg_path)
        png_result = await self.detector.scan_file(png_path)
        
        if jpeg_result:
            self.logger.info(f"🚨 JPEG Threat Detected: {jpeg_result.threat_level.value.upper()}")
            self.logger.info(f"   Confidence: {jpeg_result.confidence:.2f}")
            self.logger.info(f"   Indicators: {', '.join(jpeg_result.indicators)}")
            self.results.append(jpeg_result)
        
        if png_result:
            self.logger.info(f"🚨 PNG Threat Detected: {png_result.threat_level.value.upper()}")
            self.logger.info(f"   Confidence: {png_result.confidence:.2f}")
            self.logger.info(f"   Indicators: {', '.join(png_result.indicators)}")
            self.results.append(png_result)
        
        # Simulate deployment
        target_ios = {
            'device_id': 'iPhone_13_Pro',
            'platform': 'ios',
            'version': '15.0',
            'defense_strength': 0.3
        }
        
        deployment_result = await self.framework.deploy_exploit(ios_jpeg_exploit, target_ios)
        self.logger.info(f"📱 iOS Deployment: {'SUCCESS' if deployment_result.success else 'FAILED'}")
        if deployment_result.success:
            self.logger.info(f"   ⚡ Privilege Escalation: {'YES' if deployment_result.privilege_escalation else 'NO'}")
            self.logger.info(f"   🔒 Persistence Achieved: {'YES' if deployment_result.persistence_achieved else 'NO'}")
    
    async def demonstrate_push_notification_exploits(self):
        """Demonstrate push notification zero-click exploits"""
        self.logger.info("\n📲 DEMONSTRATING PUSH NOTIFICATION ZERO-CLICK EXPLOITS")
        self.logger.info("═" * 60)
        
        # Create APNs exploit for iOS
        apns_exploit = self.framework.create_exploit(
            ExploitType.PUSH_NOTIFICATION,
            TargetPlatform.IOS,
            {'service': 'apns'}
        )
        
        # Create FCM exploit for Android
        fcm_exploit = self.framework.create_exploit(
            ExploitType.PUSH_NOTIFICATION,
            TargetPlatform.ANDROID,
            {'service': 'fcm'}
        )
        
        # Export notification payloads
        apns_path = os.path.join(self.demo_dir, 'notifications', 'apns_payload.json')
        fcm_path = os.path.join(self.demo_dir, 'notifications', 'fcm_payload.json')
        
        self.framework.export_exploit(apns_exploit, apns_path)
        self.framework.export_exploit(fcm_exploit, fcm_path)
        
        self.logger.info(f"🍎 Created APNs exploit payload: {apns_path}")
        self.logger.info(f"🤖 Created FCM exploit payload: {fcm_path}")
        
        # Simulate notification processing
        targets = [
            {'device_id': 'iPhone_12', 'platform': 'ios', 'defense_strength': 0.2},
            {'device_id': 'Galaxy_S21', 'platform': 'android', 'defense_strength': 0.25}
        ]
        
        apns_result = await self.framework.deploy_exploit(apns_exploit, targets[0])
        fcm_result = await self.framework.deploy_exploit(fcm_exploit, targets[1])
        
        self.logger.info(f"📱 APNs Exploit: {'SUCCESS' if apns_result.success else 'FAILED'}")
        self.logger.info(f"📱 FCM Exploit: {'SUCCESS' if fcm_result.success else 'FAILED'}")
        
        if apns_result.success:
            self.logger.info("   🎯 iOS device compromised via push notification")
        if fcm_result.success:
            self.logger.info("   🎯 Android device compromised via push notification")
    
    async def demonstrate_wallet_pass_exploits(self):
        """Demonstrate wallet pass zero-click exploits"""
        self.logger.info("\n💳 DEMONSTRATING WALLET PASS ZERO-CLICK EXPLOITS")
        self.logger.info("═" * 60)
        
        # Create Apple Wallet exploit
        apple_wallet_exploit = self.framework.create_exploit(
            ExploitType.WALLET_PASS,
            TargetPlatform.IOS
        )
        
        # Create Google Pay exploit
        google_pay_exploit = self.framework.create_exploit(
            ExploitType.WALLET_PASS,
            TargetPlatform.ANDROID
        )
        
        # Export wallet passes
        apple_pass_path = os.path.join(self.demo_dir, 'wallet_passes', 'boarding_pass.pkpass')
        google_pass_path = os.path.join(self.demo_dir, 'wallet_passes', 'loyalty_card.json')
        
        self.framework.export_exploit(apple_wallet_exploit, apple_pass_path)
        self.framework.export_exploit(google_pay_exploit, google_pass_path)
        
        self.logger.info(f"🎫 Created malicious Apple Wallet pass: {apple_pass_path}")
        self.logger.info(f"💳 Created malicious Google Pay pass: {google_pass_path}")
        
        # Scan wallet passes
        apple_result = await self.detector.scan_file(apple_pass_path)
        
        if apple_result:
            self.logger.info(f"🚨 Wallet Pass Threat: {apple_result.threat_level.value.upper()}")
            self.logger.info(f"   Vector: {apple_result.exploit_vector.value}")
            self.logger.info(f"   Confidence: {apple_result.confidence:.2f}")
            self.results.append(apple_result)
        
        # Simulate wallet processing
        wallet_target = {
            'device_id': 'iPhone_14_Pro_Max',
            'platform': 'ios',
            'wallet_app': 'apple_wallet',
            'defense_strength': 0.15  # Wallet apps often have lower security
        }
        
        wallet_result = await self.framework.deploy_exploit(apple_wallet_exploit, wallet_target)
        self.logger.info(f"💳 Wallet Exploit: {'SUCCESS' if wallet_result.success else 'FAILED'}")
        
        if wallet_result.success:
            self.logger.info("   💀 Device compromised via wallet pass processing")
            self.logger.info("   📊 This attack vector has very high stealth level")
    
    async def demonstrate_voip_exploits(self):
        """Demonstrate VoIP call invite zero-click exploits"""
        self.logger.info("\n📞 DEMONSTRATING VOIP CALL INVITE ZERO-CLICK EXPLOITS")
        self.logger.info("═" * 60)
        
        # Create WebRTC exploit
        webrtc_exploit = self.framework.create_exploit(
            ExploitType.VOIP_INVITE,
            TargetPlatform.WEB_BROWSER,
            {'protocol': 'webrtc'}
        )
        
        # Create SIP exploit
        sip_exploit = self.framework.create_exploit(
            ExploitType.VOIP_INVITE,
            TargetPlatform.IOS,
            {'protocol': 'sip'}
        )
        
        # Export VoIP payloads
        webrtc_path = os.path.join(self.demo_dir, 'voip_invites', 'webrtc_offer.json')
        sip_path = os.path.join(self.demo_dir, 'voip_invites', 'sip_invite.txt')
        
        self.framework.export_exploit(webrtc_exploit, webrtc_path)
        self.framework.export_exploit(sip_exploit, sip_path)
        
        self.logger.info(f"🌐 Created WebRTC exploit: {webrtc_path}")
        self.logger.info(f"📱 Created SIP exploit: {sip_path}")
        
        # Simulate VoIP processing
        voip_targets = [
            {'device_id': 'Chrome_Browser', 'platform': 'web', 'defense_strength': 0.4},
            {'device_id': 'iPhone_13', 'platform': 'ios', 'defense_strength': 0.3}
        ]
        
        webrtc_result = await self.framework.deploy_exploit(webrtc_exploit, voip_targets[0])
        sip_result = await self.framework.deploy_exploit(sip_exploit, voip_targets[1])
        
        self.logger.info(f"🌐 WebRTC Exploit: {'SUCCESS' if webrtc_result.success else 'FAILED'}")
        self.logger.info(f"📱 SIP Exploit: {'SUCCESS' if sip_result.success else 'FAILED'}")
    
    async def demonstrate_pdf_exploits(self):
        """Demonstrate PDF JavaScript zero-click exploits"""
        self.logger.info("\n📄 DEMONSTRATING PDF JAVASCRIPT ZERO-CLICK EXPLOITS")
        self.logger.info("═" * 60)
        
        # Create PDF exploit
        pdf_exploit = self.framework.create_exploit(
            ExploitType.PDF_JAVASCRIPT,
            TargetPlatform.WINDOWS
        )
        
        # Export PDF
        pdf_path = os.path.join(self.demo_dir, 'pdf_documents', 'invoice.pdf')
        self.framework.export_exploit(pdf_exploit, pdf_path)
        
        self.logger.info(f"📄 Created malicious PDF: {pdf_path}")
        
        # Scan PDF
        pdf_result = await self.detector.scan_file(pdf_path)
        
        if pdf_result:
            self.logger.info(f"🚨 PDF Threat: {pdf_result.threat_level.value.upper()}")
            self.logger.info(f"   JavaScript detected: Auto-execution enabled")
            self.logger.info(f"   Confidence: {pdf_result.confidence:.2f}")
            self.results.append(pdf_result)
        
        # Simulate PDF opening
        pdf_target = {
            'device_id': 'Windows_Workstation',
            'platform': 'windows',
            'pdf_reader': 'adobe_reader',
            'defense_strength': 0.35
        }
        
        pdf_result = await self.framework.deploy_exploit(pdf_exploit, pdf_target)
        self.logger.info(f"📄 PDF Exploit: {'SUCCESS' if pdf_result.success else 'FAILED'}")
    
    async def demonstrate_bluetooth_exploits(self):
        """Demonstrate Bluetooth beacon zero-click exploits"""
        self.logger.info("\n📡 DEMONSTRATING BLUETOOTH BEACON ZERO-CLICK EXPLOITS")
        self.logger.info("═" * 60)
        
        # Create Bluetooth exploit
        ble_exploit = self.framework.create_exploit(
            ExploitType.BLUETOOTH_BEACON,
            TargetPlatform.IOS
        )
        
        # Export Bluetooth payload
        ble_path = os.path.join(self.demo_dir, 'bluetooth_beacons', 'ble_advertisement.json')
        self.framework.export_exploit(ble_exploit, ble_path)
        
        self.logger.info(f"📡 Created Bluetooth beacon exploit: {ble_path}")
        
        # Simulate proximity attack
        ble_target = {
            'device_id': 'iPhone_15_Pro',
            'platform': 'ios',
            'bluetooth_enabled': True,
            'defense_strength': 0.1  # Very low detection for proximity attacks
        }
        
        ble_result = await self.framework.deploy_exploit(ble_exploit, ble_target)
        self.logger.info(f"📡 Bluetooth Exploit: {'SUCCESS' if ble_result.success else 'FAILED'}")
        
        if ble_result.success:
            self.logger.info("   👻 Completely silent proximity-based compromise")
            self.logger.info("   📍 No user interaction or notification required")
    
    async def demonstrate_font_exploits(self):
        """Demonstrate font parsing zero-click exploits"""
        self.logger.info("\n🔤 DEMONSTRATING FONT PARSING ZERO-CLICK EXPLOITS")
        self.logger.info("═" * 60)
        
        # Create font exploit
        font_exploit = self.framework.create_exploit(
            ExploitType.FONT_PARSER,
            TargetPlatform.MACOS
        )
        
        # Export font file
        font_path = os.path.join(self.demo_dir, 'fonts', 'custom_font.ttf')
        self.framework.export_exploit(font_exploit, font_path)
        
        self.logger.info(f"🔤 Created malicious font: {font_path}")
        
        # Simulate font rendering
        font_target = {
            'device_id': 'MacBook_Pro_M2',
            'platform': 'macos',
            'font_rendering': 'core_text',
            'defense_strength': 0.25
        }
        
        font_result = await self.framework.deploy_exploit(font_exploit, font_target)
        self.logger.info(f"🔤 Font Exploit: {'SUCCESS' if font_result.success else 'FAILED'}")
    
    async def demonstrate_media_exploits(self):
        """Demonstrate audio/video codec zero-click exploits"""
        self.logger.info("\n🎵 DEMONSTRATING MEDIA CODEC ZERO-CLICK EXPLOITS")
        self.logger.info("═" * 60)
        
        # Create audio exploit
        audio_exploit = self.framework.create_exploit(
            ExploitType.AUDIO_CODEC,
            TargetPlatform.ANDROID
        )
        
        # Create video exploit
        video_exploit = self.framework.create_exploit(
            ExploitType.VIDEO_CODEC,
            TargetPlatform.IOS
        )
        
        # Export media files
        audio_path = os.path.join(self.demo_dir, 'audio', 'voice_message.mp3')
        video_path = os.path.join(self.demo_dir, 'video', 'vacation_video.mp4')
        
        self.framework.export_exploit(audio_exploit, audio_path)
        self.framework.export_exploit(video_exploit, video_path)
        
        self.logger.info(f"🎵 Created malicious audio: {audio_path}")
        self.logger.info(f"🎬 Created malicious video: {video_path}")
        
        # Scan media files
        audio_result = await self.detector.scan_file(audio_path)
        video_result = await self.detector.scan_file(video_path)
        
        if audio_result:
            self.logger.info(f"🚨 Audio Threat: {audio_result.threat_level.value.upper()}")
            self.results.append(audio_result)
        
        if video_result:
            self.logger.info(f"🚨 Video Threat: {video_result.threat_level.value.upper()}")
            self.results.append(video_result)
        
        # Simulate media processing
        media_targets = [
            {'device_id': 'Galaxy_Note', 'platform': 'android', 'defense_strength': 0.3},
            {'device_id': 'iPhone_14', 'platform': 'ios', 'defense_strength': 0.25}
        ]
        
        audio_result = await self.framework.deploy_exploit(audio_exploit, media_targets[0])
        video_result = await self.framework.deploy_exploit(video_exploit, media_targets[1])
        
        self.logger.info(f"🎵 Audio Exploit: {'SUCCESS' if audio_result.success else 'FAILED'}")
        self.logger.info(f"🎬 Video Exploit: {'SUCCESS' if video_result.success else 'FAILED'}")
    
    async def run_comprehensive_scan(self):
        """Run comprehensive scan of all created exploits"""
        self.logger.info("\n🔍 RUNNING COMPREHENSIVE ZERO-CLICK EXPLOIT SCAN")
        self.logger.info("═" * 60)
        
        # Scan entire demo directory
        scan_results = await self.detector.scan_directory(self.demo_dir)
        
        self.logger.info(f"📊 Scanned {self.detector.get_detection_stats()['total_scanned']} files")
        self.logger.info(f"🚨 Detected {len(scan_results)} zero-click exploits")
        
        # Categorize threats by level
        threat_counts = {level.value: 0 for level in ThreatLevel}
        for result in scan_results:
            threat_counts[result.threat_level.value] += 1
        
        self.logger.info("\n📈 THREAT LEVEL BREAKDOWN:")
        for level, count in threat_counts.items():
            if count > 0:
                self.logger.info(f"   {level.upper()}: {count} threats")
        
        # Generate comprehensive report
        report = self.detector.generate_report(scan_results)
        
        report_path = os.path.join(self.demo_dir, 'zero_click_detection_report.json')
        with open(report_path, 'w') as f:
            json.dump(report, f, indent=2)
        
        self.logger.info(f"\n📄 Detailed report saved to: {report_path}")
        
        return scan_results
    
    def generate_framework_statistics(self):
        """Generate and display framework statistics"""
        self.logger.info("\n📊 ZERO-CLICK EXPLOIT FRAMEWORK STATISTICS")
        self.logger.info("═" * 60)
        
        stats = self.framework.get_exploit_stats()
        
        self.logger.info(f"🎯 Total Exploits Created: {stats['total_exploits_created']}")
        self.logger.info(f"🚀 Total Deployments: {stats['total_deployments']}")
        self.logger.info(f"✅ Successful Exploits: {stats['successful_exploits']}")
        self.logger.info(f"🔍 Detected Exploits: {stats['detected_exploits']}")
        self.logger.info(f"📈 Success Rate: {stats['success_rate']:.2%}")
        self.logger.info(f"🛡️ Detection Rate: {stats['detection_rate']:.2%}")
        
        self.logger.info("\n🎭 EXPLOIT TYPES BREAKDOWN:")
        for exploit_type, count in stats['exploit_types'].items():
            if count > 0:
                self.logger.info(f"   {exploit_type.replace('_', ' ').title()}: {count}")
        
        self.logger.info("\n📱 TARGET PLATFORMS BREAKDOWN:")
        for platform, count in stats['target_platforms'].items():
            if count > 0:
                self.logger.info(f"   {platform.upper()}: {count}")
    
    def print_summary(self):
        """Print demonstration summary"""
        summary = """
╔══════════════════════════════════════════════════════════════════════════════╗
║                    🎯 ZERO-CLICK EXPLOIT DEMONSTRATION COMPLETE 🎯            ║
║                                                                              ║
║  CAPABILITIES DEMONSTRATED:                                                  ║
║  ═══════════════════════════                                                ║
║                                                                              ║
║  ✅ Image Parser Exploits     - JPEG/PNG vulnerabilities                    ║
║  ✅ Push Notification Exploits - APNs/FCM payload injection                 ║
║  ✅ Wallet Pass Exploits      - Apple Wallet/Google Pay                     ║
║  ✅ VoIP Call Exploits        - WebRTC/SIP processing                       ║
║  ✅ PDF JavaScript Exploits   - Auto-execution vulnerabilities              ║
║  ✅ Bluetooth Beacon Exploits - Proximity-based attacks                     ║
║  ✅ Font Parsing Exploits     - Font rendering vulnerabilities              ║
║  ✅ Media Codec Exploits      - Audio/Video processing                      ║
║  ✅ Real-time Detection       - Advanced threat analysis                    ║
║  ✅ Comprehensive Reporting   - Detailed security assessment                ║
║                                                                              ║
║  🔒 SECURITY IMPLICATIONS:                                                   ║
║  ═══════════════════════                                                    ║
║                                                                              ║
║  • Zero-click exploits require NO user interaction                          ║
║  • Payloads execute automatically during data processing                    ║
║  • Extremely difficult to detect without advanced tools                     ║
║  • Can achieve full device compromise silently                              ║
║  • Represent the most sophisticated attack vectors                          ║
║                                                                              ║
║  ⚠️  USE RESPONSIBLY FOR SECURITY RESEARCH AND DEFENSE ONLY ⚠️               ║
╚══════════════════════════════════════════════════════════════════════════════╝
        """
        print(summary)
    
    async def run_full_demonstration(self):
        """Run the complete zero-click exploit demonstration"""
        try:
            self.print_banner()
            
            await self.setup_demo_environment()
            
            # Demonstrate all exploit types
            await self.demonstrate_image_exploits()
            await self.demonstrate_push_notification_exploits()
            await self.demonstrate_wallet_pass_exploits()
            await self.demonstrate_voip_exploits()
            await self.demonstrate_pdf_exploits()
            await self.demonstrate_bluetooth_exploits()
            await self.demonstrate_font_exploits()
            await self.demonstrate_media_exploits()
            
            # Run comprehensive analysis
            scan_results = await self.run_comprehensive_scan()
            
            # Generate statistics
            self.generate_framework_statistics()
            
            # Print summary
            self.print_summary()
            
            self.logger.info(f"\n🎉 Demonstration complete! Files created in: {self.demo_dir}")
            self.logger.info("📝 Check zero_click_demo.log for detailed logs")
            
            return True
            
        except Exception as e:
            self.logger.error(f"❌ Demonstration failed: {e}")
            return False

async def main():
    """Main demonstration function"""
    demo = ZeroClickDemo()
    success = await demo.run_full_demonstration()
    
    if success:
        print("\n✅ Zero-click exploit demonstration completed successfully!")
        print(f"📁 Demo files available at: {demo.demo_dir}")
        print("📊 Check the generated reports for detailed analysis")
    else:
        print("\n❌ Demonstration encountered errors. Check logs for details.")
        return 1
    
    return 0

if __name__ == "__main__":
    import sys
    sys.exit(asyncio.run(main()))