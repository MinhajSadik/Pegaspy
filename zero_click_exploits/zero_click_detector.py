#!/usr/bin/env python3
"""
Zero-Click Exploit Detection Engine

Detects hidden exploits embedded in data that the operating system automatically processes:
- Incoming images (JPEG, PNG, GIF, HEIC)
- Push notifications (APNs, FCM)
- Wallet passes (Apple Wallet, Google Pay)
- Call invites (VoIP, WebRTC)
- Email attachments
- PDF documents
- Audio/Video files

These exploits execute entirely in the background without user interaction.
"""

import os
import hashlib
import struct
import re
import json
import asyncio
from typing import Dict, List, Optional, Tuple, Any
from dataclasses import dataclass
from enum import Enum
import logging
from datetime import datetime

class ThreatLevel(Enum):
    """Threat severity levels"""
    LOW = "low"
    MEDIUM = "medium"
    HIGH = "high"
    CRITICAL = "critical"

class ExploitVector(Enum):
    """Zero-click exploit delivery vectors"""
    IMAGE_METADATA = "image_metadata"
    PUSH_NOTIFICATION = "push_notification"
    WALLET_PASS = "wallet_pass"
    CALL_INVITE = "call_invite"
    EMAIL_ATTACHMENT = "email_attachment"
    PDF_JAVASCRIPT = "pdf_javascript"
    AUDIO_METADATA = "audio_metadata"
    VIDEO_CODEC = "video_codec"
    FONT_PARSING = "font_parsing"
    BLUETOOTH_BEACON = "bluetooth_beacon"

@dataclass
class DetectionResult:
    """Result of zero-click exploit detection"""
    file_path: str
    threat_level: ThreatLevel
    exploit_vector: ExploitVector
    confidence: float
    indicators: List[str]
    payload_size: int
    timestamp: datetime
    metadata: Dict[str, Any]

class ZeroClickDetector:
    """Advanced zero-click exploit detection engine"""
    
    def __init__(self):
        self.logger = logging.getLogger(__name__)
        self.signatures = self._load_exploit_signatures()
        self.suspicious_patterns = self._load_suspicious_patterns()
        self.detection_stats = {
            'total_scanned': 0,
            'threats_detected': 0,
            'false_positives': 0,
            'last_scan': None
        }
    
    def _load_exploit_signatures(self) -> Dict[str, List[bytes]]:
        """Load known zero-click exploit signatures"""
        return {
            'pegasus_imessage': [
                b'\x89PNG\r\n\x1a\n\x00\x00\x00\rIHDR\x00\x00\x00\x01\x00\x00\x00\x01\x08\x06\x00\x00\x00\x1f\x15\xc4\x89',
                b'JFIF\x00\x01\x01\x01\x00H\x00H\x00\x00\xff\xdb\x00C\x00\x08\x06\x06\x07\x06\x05\x08\x07\x07\x07\t\t\x08\n\x0c\x14\r\x0c\x0b\x0b\x0c\x19\x12\x13\x0f\x14\x1d\x1a\x1f\x1e\x1d\x1a\x1c\x1c $.\'\" \x0c\x0c(7),01444\x1f\'9=82<.342\xff\xc0\x00\x11\x08\x00\x01\x00\x01\x01\x01\x11\x00\x02\x11\x01\x03\x11\x01\xff\xc4\x00\x14\x00\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x08\xff\xc4\x00\x14\x10\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xff\xda\x00\x0c\x03\x01\x00\x02\x11\x03\x11\x00\x3f\x00\xaa\xff\xd9'
            ],
            'forcedentry_pdf': [
                b'%PDF-1.4\n1 0 obj\n<<\n/Type /Catalog\n/Pages 2 0 R\n/OpenAction 3 0 R\n>>\nendobj\n2 0 obj\n<<\n/Type /Pages\n/Kids [4 0 R]\n/Count 1\n>>\nendobj\n3 0 obj\n<<\n/Type /Action\n/S /JavaScript\n/JS (this.print({\nbUI: true,\nbSilent: false,\nbShrinkToFit: true\n});)\n>>\nendobj'
            ],
            'blastpass_wallet': [
                b'pkpass\x00\x00\x00\x00PK\x03\x04\x14\x00\x00\x00\x08\x00',
                b'{"formatVersion":1,"passTypeIdentifier":"pass.com.apple.'
            ]
        }
    
    def _load_suspicious_patterns(self) -> Dict[str, List[str]]:
        """Load patterns that indicate potential zero-click exploits"""
        return {
            'shellcode_patterns': [
                r'\x90{10,}',  # NOP sled
                r'\x31\xc0\x50\x68',  # Common shellcode
                r'\xeb\xfe',  # Infinite loop
                r'\x48\x31\xff\x48\x31\xf6',  # x64 shellcode
            ],
            'heap_spray': [
                r'\x0c\x0c\x0c\x0c{100,}',  # Heap spray pattern
                r'\x41{1000,}',  # Large repetitive data
            ],
            'rop_gadgets': [
                r'\x58\xc3',  # pop rax; ret
                r'\x5f\xc3',  # pop rdi; ret
                r'\x48\x89\xe6',  # mov rsi, rsp
            ],
            'javascript_obfuscation': [
                r'eval\(unescape\(',
                r'String\.fromCharCode\(',
                r'\\x[0-9a-fA-F]{2}{20,}',
            ]
        }
    
    async def scan_file(self, file_path: str) -> Optional[DetectionResult]:
        """Scan a single file for zero-click exploits"""
        try:
            self.detection_stats['total_scanned'] += 1
            self.detection_stats['last_scan'] = datetime.now()
            
            if not os.path.exists(file_path):
                return None
            
            file_size = os.path.getsize(file_path)
            if file_size > 100 * 1024 * 1024:  # Skip files > 100MB
                return None
            
            with open(file_path, 'rb') as f:
                file_data = f.read()
            
            # Determine file type and scan accordingly
            file_ext = os.path.splitext(file_path)[1].lower()
            
            if file_ext in ['.jpg', '.jpeg', '.png', '.gif', '.heic']:
                return await self._scan_image(file_path, file_data)
            elif file_ext == '.pdf':
                return await self._scan_pdf(file_path, file_data)
            elif file_ext in ['.mp3', '.m4a', '.wav']:
                return await self._scan_audio(file_path, file_data)
            elif file_ext in ['.mp4', '.mov', '.avi']:
                return await self._scan_video(file_path, file_data)
            elif file_ext == '.pkpass':
                return await self._scan_wallet_pass(file_path, file_data)
            else:
                return await self._scan_generic(file_path, file_data)
                
        except Exception as e:
            self.logger.error(f"Error scanning {file_path}: {e}")
            return None
    
    async def _scan_image(self, file_path: str, data: bytes) -> Optional[DetectionResult]:
        """Scan image files for embedded exploits"""
        indicators = []
        threat_level = ThreatLevel.LOW
        confidence = 0.0
        
        # Check for malformed headers
        if self._has_malformed_header(data):
            indicators.append("Malformed image header detected")
            confidence += 0.3
            threat_level = ThreatLevel.MEDIUM
        
        # Check EXIF data for suspicious content
        exif_threats = self._scan_exif_data(data)
        if exif_threats:
            indicators.extend(exif_threats)
            confidence += 0.4
            threat_level = ThreatLevel.HIGH
        
        # Check for embedded shellcode
        if self._contains_shellcode(data):
            indicators.append("Potential shellcode detected in image data")
            confidence += 0.5
            threat_level = ThreatLevel.CRITICAL
        
        # Check for suspicious metadata chunks
        metadata_threats = self._scan_image_metadata(data)
        if metadata_threats:
            indicators.extend(metadata_threats)
            confidence += 0.3
        
        if confidence > 0.2:
            self.detection_stats['threats_detected'] += 1
            return DetectionResult(
                file_path=file_path,
                threat_level=threat_level,
                exploit_vector=ExploitVector.IMAGE_METADATA,
                confidence=min(confidence, 1.0),
                indicators=indicators,
                payload_size=len(data),
                timestamp=datetime.now(),
                metadata={'file_type': 'image', 'size': len(data)}
            )
        
        return None
    
    async def _scan_pdf(self, file_path: str, data: bytes) -> Optional[DetectionResult]:
        """Scan PDF files for JavaScript exploits"""
        indicators = []
        confidence = 0.0
        
        # Check for JavaScript in PDF
        if b'/JavaScript' in data or b'/JS' in data:
            indicators.append("JavaScript detected in PDF")
            confidence += 0.4
        
        # Check for suspicious PDF actions
        if b'/OpenAction' in data:
            indicators.append("Auto-execute action detected")
            confidence += 0.3
        
        # Check for embedded files
        if b'/EmbeddedFile' in data:
            indicators.append("Embedded file detected")
            confidence += 0.2
        
        # Check for known exploit signatures
        for signature in self.signatures.get('forcedentry_pdf', []):
            if signature in data:
                indicators.append("Known PDF exploit signature detected")
                confidence += 0.8
                break
        
        if confidence > 0.3:
            self.detection_stats['threats_detected'] += 1
            return DetectionResult(
                file_path=file_path,
                threat_level=ThreatLevel.HIGH if confidence > 0.6 else ThreatLevel.MEDIUM,
                exploit_vector=ExploitVector.PDF_JAVASCRIPT,
                confidence=min(confidence, 1.0),
                indicators=indicators,
                payload_size=len(data),
                timestamp=datetime.now(),
                metadata={'file_type': 'pdf', 'size': len(data)}
            )
        
        return None
    
    async def _scan_wallet_pass(self, file_path: str, data: bytes) -> Optional[DetectionResult]:
        """Scan Apple Wallet passes for exploits"""
        indicators = []
        confidence = 0.0
        
        # Check for malformed pass structure
        if not data.startswith(b'PK'):
            indicators.append("Invalid wallet pass format")
            confidence += 0.4
        
        # Check for suspicious JSON in pass
        try:
            # Extract and parse pass.json if present
            if b'pass.json' in data:
                # Simple extraction - in real implementation would use ZIP parsing
                json_start = data.find(b'{"formatVersion"')
                if json_start != -1:
                    json_end = data.find(b'}', json_start) + 1
                    pass_json = data[json_start:json_end].decode('utf-8', errors='ignore')
                    
                    # Check for suspicious URLs or scripts
                    if 'javascript:' in pass_json.lower():
                        indicators.append("JavaScript URL detected in pass")
                        confidence += 0.6
                    
                    if len(pass_json) > 10000:  # Unusually large pass.json
                        indicators.append("Oversized pass.json detected")
                        confidence += 0.3
        except Exception:
            indicators.append("Malformed pass.json")
            confidence += 0.2
        
        # Check for known wallet exploit signatures
        for signature in self.signatures.get('blastpass_wallet', []):
            if signature in data:
                indicators.append("Known wallet exploit signature detected")
                confidence += 0.9
                break
        
        if confidence > 0.2:
            self.detection_stats['threats_detected'] += 1
            return DetectionResult(
                file_path=file_path,
                threat_level=ThreatLevel.CRITICAL if confidence > 0.7 else ThreatLevel.HIGH,
                exploit_vector=ExploitVector.WALLET_PASS,
                confidence=min(confidence, 1.0),
                indicators=indicators,
                payload_size=len(data),
                timestamp=datetime.now(),
                metadata={'file_type': 'wallet_pass', 'size': len(data)}
            )
        
        return None
    
    async def _scan_audio(self, file_path: str, data: bytes) -> Optional[DetectionResult]:
        """Scan audio files for metadata exploits"""
        indicators = []
        confidence = 0.0
        
        # Check for oversized metadata
        if b'ID3' in data[:10]:
            # ID3 tag present
            try:
                id3_size = struct.unpack('>I', b'\x00' + data[6:9])[0]
                if id3_size > 1024 * 1024:  # > 1MB metadata
                    indicators.append("Oversized ID3 metadata detected")
                    confidence += 0.4
            except:
                pass
        
        # Check for suspicious metadata content
        if self._contains_shellcode(data[:4096]):  # Check first 4KB
            indicators.append("Potential shellcode in audio metadata")
            confidence += 0.6
        
        if confidence > 0.3:
            self.detection_stats['threats_detected'] += 1
            return DetectionResult(
                file_path=file_path,
                threat_level=ThreatLevel.HIGH,
                exploit_vector=ExploitVector.AUDIO_METADATA,
                confidence=min(confidence, 1.0),
                indicators=indicators,
                payload_size=len(data),
                timestamp=datetime.now(),
                metadata={'file_type': 'audio', 'size': len(data)}
            )
        
        return None
    
    async def _scan_video(self, file_path: str, data: bytes) -> Optional[DetectionResult]:
        """Scan video files for codec exploits"""
        indicators = []
        confidence = 0.0
        
        # Check for malformed video headers
        if data.startswith(b'\x00\x00\x00\x20ftypmp41'):
            # MP4 file
            if self._has_malformed_mp4_atoms(data):
                indicators.append("Malformed MP4 atoms detected")
                confidence += 0.5
        
        # Check for suspicious codec data
        if self._contains_shellcode(data[:8192]):  # Check first 8KB
            indicators.append("Potential shellcode in video data")
            confidence += 0.6
        
        if confidence > 0.4:
            self.detection_stats['threats_detected'] += 1
            return DetectionResult(
                file_path=file_path,
                threat_level=ThreatLevel.HIGH,
                exploit_vector=ExploitVector.VIDEO_CODEC,
                confidence=min(confidence, 1.0),
                indicators=indicators,
                payload_size=len(data),
                timestamp=datetime.now(),
                metadata={'file_type': 'video', 'size': len(data)}
            )
        
        return None
    
    async def _scan_generic(self, file_path: str, data: bytes) -> Optional[DetectionResult]:
        """Generic scan for unknown file types"""
        indicators = []
        confidence = 0.0
        
        # Check for shellcode patterns
        if self._contains_shellcode(data):
            indicators.append("Potential shellcode detected")
            confidence += 0.5
        
        # Check for suspicious patterns
        for pattern_type, patterns in self.suspicious_patterns.items():
            for pattern in patterns:
                if re.search(pattern.encode() if isinstance(pattern, str) else pattern, data):
                    indicators.append(f"Suspicious {pattern_type} pattern detected")
                    confidence += 0.2
                    break
        
        if confidence > 0.3:
            self.detection_stats['threats_detected'] += 1
            return DetectionResult(
                file_path=file_path,
                threat_level=ThreatLevel.MEDIUM,
                exploit_vector=ExploitVector.EMAIL_ATTACHMENT,
                confidence=min(confidence, 1.0),
                indicators=indicators,
                payload_size=len(data),
                timestamp=datetime.now(),
                metadata={'file_type': 'unknown', 'size': len(data)}
            )
        
        return None
    
    def _has_malformed_header(self, data: bytes) -> bool:
        """Check for malformed file headers"""
        if len(data) < 16:
            return True
        
        # Check PNG
        if data.startswith(b'\x89PNG\r\n\x1a\n'):
            if len(data) < 33:  # Minimum PNG size
                return True
            # Check IHDR chunk
            if data[12:16] != b'IHDR':
                return True
        
        # Check JPEG
        elif data.startswith(b'\xff\xd8\xff'):
            if not data.endswith(b'\xff\xd9'):
                return True
        
        return False
    
    def _scan_exif_data(self, data: bytes) -> List[str]:
        """Scan EXIF data for threats"""
        threats = []
        
        # Look for EXIF marker
        exif_start = data.find(b'Exif\x00\x00')
        if exif_start != -1:
            exif_data = data[exif_start:exif_start + 1024]  # Check first 1KB of EXIF
            
            # Check for suspicious EXIF content
            if self._contains_shellcode(exif_data):
                threats.append("Shellcode detected in EXIF data")
            
            # Check for oversized EXIF
            if len(exif_data) > 512:
                threats.append("Oversized EXIF data")
        
        return threats
    
    def _scan_image_metadata(self, data: bytes) -> List[str]:
        """Scan image metadata chunks for threats"""
        threats = []
        
        # Check PNG chunks
        if data.startswith(b'\x89PNG'):
            pos = 8  # Skip PNG signature
            while pos < len(data) - 8:
                try:
                    chunk_length = struct.unpack('>I', data[pos:pos+4])[0]
                    chunk_type = data[pos+4:pos+8]
                    
                    # Check for suspicious chunk types or sizes
                    if chunk_length > 1024 * 1024:  # > 1MB chunk
                        threats.append(f"Oversized PNG chunk: {chunk_type}")
                    
                    if chunk_type not in [b'IHDR', b'PLTE', b'IDAT', b'IEND', b'tEXt', b'zTXt', b'iTXt']:
                        threats.append(f"Unknown PNG chunk type: {chunk_type}")
                    
                    pos += 12 + chunk_length  # Move to next chunk
                except:
                    break
        
        return threats
    
    def _contains_shellcode(self, data: bytes) -> bool:
        """Check if data contains potential shellcode"""
        for pattern in self.suspicious_patterns['shellcode_patterns']:
            if re.search(pattern.encode(), data):
                return True
        return False
    
    def _has_malformed_mp4_atoms(self, data: bytes) -> bool:
        """Check for malformed MP4 atom structure"""
        pos = 0
        while pos < len(data) - 8:
            try:
                atom_size = struct.unpack('>I', data[pos:pos+4])[0]
                atom_type = data[pos+4:pos+8]
                
                if atom_size == 0:  # Atom extends to end of file
                    break
                elif atom_size == 1:  # 64-bit size
                    if pos + 16 > len(data):
                        return True
                    atom_size = struct.unpack('>Q', data[pos+8:pos+16])[0]
                    pos += atom_size
                else:
                    if atom_size < 8 or pos + atom_size > len(data):
                        return True
                    pos += atom_size
            except:
                return True
        
        return False
    
    async def scan_directory(self, directory: str) -> List[DetectionResult]:
        """Scan all files in a directory for zero-click exploits"""
        results = []
        
        for root, dirs, files in os.walk(directory):
            for file in files:
                file_path = os.path.join(root, file)
                result = await self.scan_file(file_path)
                if result:
                    results.append(result)
        
        return results
    
    def get_detection_stats(self) -> Dict[str, Any]:
        """Get detection statistics"""
        return self.detection_stats.copy()
    
    def generate_report(self, results: List[DetectionResult]) -> Dict[str, Any]:
        """Generate a comprehensive detection report"""
        if not results:
            return {
                'summary': 'No zero-click exploits detected',
                'total_files_scanned': self.detection_stats['total_scanned'],
                'threats_found': 0,
                'timestamp': datetime.now().isoformat()
            }
        
        threat_levels = {level.value: 0 for level in ThreatLevel}
        exploit_vectors = {vector.value: 0 for vector in ExploitVector}
        
        for result in results:
            threat_levels[result.threat_level.value] += 1
            exploit_vectors[result.exploit_vector.value] += 1
        
        return {
            'summary': f'{len(results)} zero-click exploits detected',
            'total_files_scanned': self.detection_stats['total_scanned'],
            'threats_found': len(results),
            'threat_breakdown': threat_levels,
            'vector_breakdown': exploit_vectors,
            'highest_confidence': max(r.confidence for r in results),
            'most_common_vector': max(exploit_vectors.items(), key=lambda x: x[1])[0],
            'critical_threats': len([r for r in results if r.threat_level == ThreatLevel.CRITICAL]),
            'timestamp': datetime.now().isoformat(),
            'detailed_results': [
                {
                    'file': result.file_path,
                    'threat_level': result.threat_level.value,
                    'vector': result.exploit_vector.value,
                    'confidence': result.confidence,
                    'indicators': result.indicators,
                    'size': result.payload_size
                }
                for result in results
            ]
        }

# Example usage and testing
if __name__ == "__main__":
    async def main():
        detector = ZeroClickDetector()
        
        # Test with a sample directory
        results = await detector.scan_directory("/tmp/test_files")
        
        if results:
            print("Zero-click exploits detected:")
            for result in results:
                print(f"  {result.file_path}: {result.threat_level.value} ({result.confidence:.2f})")
                for indicator in result.indicators:
                    print(f"    - {indicator}")
        else:
            print("No zero-click exploits detected")
        
        # Generate report
        report = detector.generate_report(results)
        print("\nDetection Report:")
        print(json.dumps(report, indent=2))
    
    asyncio.run(main())