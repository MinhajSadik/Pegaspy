#!/usr/bin/env python3
"""
iMessage Threat Detection
Detection signatures and analysis for iMessage-based security threats
This module helps identify potential spyware and malicious content in messages
"""

import hashlib
import re
from typing import Dict, List, Optional, Tuple
from dataclasses import dataclass
from enum import Enum

class ThreatLevel(Enum):
    LOW = "low"
    MEDIUM = "medium"  
    HIGH = "high"
    CRITICAL = "critical"

class VulnerabilityType(Enum):
    SUSPICIOUS_IMAGE = "suspicious_image"
    MALFORMED_ATTACHMENT = "malformed_attachment"
    SUSPICIOUS_NOTIFICATION = "suspicious_notification"
    MEMORY_CORRUPTION_INDICATOR = "memory_corruption"
    ZERO_CLICK_INDICATOR = "zero_click_indicator"

@dataclass
class ThreatSignature:
    signature_id: str
    vulnerability_type: VulnerabilityType
    threat_level: ThreatLevel
    description: str
    detection_patterns: List[bytes]
    file_extensions: List[str]
    indicators: List[str]

class IMessageThreatDetector:
    """Detects potential spyware threats in iMessage content"""
    
    def __init__(self):
        self.threat_signatures = self._load_threat_signatures()
        self.scan_results = []
    
    def _load_threat_signatures(self) -> Dict[str, ThreatSignature]:
        """Load known threat signatures for detection"""
        signatures = {}
        
        # CoreGraphics-related threats
        signatures['cg_malformed_jpeg'] = ThreatSignature(
            signature_id='cg_malformed_jpeg',
            vulnerability_type=VulnerabilityType.SUSPICIOUS_IMAGE,
            threat_level=ThreatLevel.HIGH,
            description='Potentially malicious JPEG with suspicious EXIF data',
            detection_patterns=[
                b'\xff\xe1',  # EXIF marker
                b'\x00\x16Exif',  # EXIF header
                b'\xff\xff\xff\xff',  # Suspicious count values
            ],
            file_extensions=['.jpg', '.jpeg'],
            indicators=['Malformed EXIF', 'Suspicious dimensions', 'Invalid TIFF structure']
        )
        
        # ImageIO-related threats
        signatures['imageio_malformed_png'] = ThreatSignature(
            signature_id='imageio_malformed_png',
            vulnerability_type=VulnerabilityType.SUSPICIOUS_IMAGE,
            threat_level=ThreatLevel.HIGH,
            description='Potentially malicious PNG with integer overflow attempts',
            detection_patterns=[
                b'\x89PNG\r\n\x1a\n',  # PNG signature
                b'IHDR',  # Image header
                b'\xff\xff\xff\xff',  # Suspicious width/height
            ],
            file_extensions=['.png'],
            indicators=['Suspicious dimensions', 'Malformed chunks', 'Invalid CRC']
        )
        
        # Notification-based threats
        signatures['suspicious_notification'] = ThreatSignature(
            signature_id='suspicious_notification',
            vulnerability_type=VulnerabilityType.SUSPICIOUS_NOTIFICATION,
            threat_level=ThreatLevel.CRITICAL,
            description='Suspicious push notification with potential exploit content',
            detection_patterns=[
                b'\x00' * 100,  # Null byte patterns
                b'\\x',  # Hex encoding patterns
                b'\xff\xff\xff\xff',  # Integer overflow patterns
            ],
            file_extensions=['.json'],
            indicators=['Excessive null bytes', 'Encoded payloads', 'Suspicious badge values']
        )
        
        return signatures
    
    def scan_file(self, file_path: str, file_data: bytes) -> Dict:
        """Scan a file for potential threats"""
        scan_result = {
            'file_path': file_path,
            'file_size': len(file_data),
            'threats_detected': [],
            'threat_level': ThreatLevel.LOW,
            'file_hash': hashlib.sha256(file_data).hexdigest(),
            'analysis_timestamp': None
        }
        
        # Get file extension
        file_ext = '.' + file_path.split('.')[-1].lower() if '.' in file_path else ''
        
        # Check against threat signatures
        for signature_id, signature in self.threat_signatures.items():
            if file_ext in signature.file_extensions or not signature.file_extensions:
                threat_detected = self._check_signature(file_data, signature)
                if threat_detected:
                    scan_result['threats_detected'].append({
                        'signature_id': signature_id,
                        'description': signature.description,
                        'threat_level': signature.threat_level.value,
                        'indicators': signature.indicators
                    })
                    
                    # Update overall threat level
                    if signature.threat_level.value == 'critical':
                        scan_result['threat_level'] = ThreatLevel.CRITICAL
                    elif signature.threat_level.value == 'high' and scan_result['threat_level'] != ThreatLevel.CRITICAL:
                        scan_result['threat_level'] = ThreatLevel.HIGH
        
        return scan_result
    
    def _check_signature(self, file_data: bytes, signature: ThreatSignature) -> bool:
        """Check if file data matches a threat signature"""
        matches = 0
        required_matches = len(signature.detection_patterns)
        
        for pattern in signature.detection_patterns:
            if pattern in file_data:
                matches += 1
        
        # Require at least 60% of patterns to match
        return matches >= (required_matches * 0.6)
    
    def analyze_message_content(self, message_content: str) -> Dict:
        """Analyze message text content for suspicious patterns"""
        analysis = {
            'suspicious_patterns': [],
            'threat_indicators': [],
            'risk_score': 0
        }
        
        # Check for suspicious Unicode patterns
        unicode_pattern = re.compile(r'\\u[0-9a-fA-F]{4}')
        if unicode_pattern.search(message_content):
            analysis['suspicious_patterns'].append('Unicode escape sequences')
            analysis['risk_score'] += 10
        
        # Check for hex-encoded content
        hex_pattern = re.compile(r'\\x[0-9a-fA-F]{2}')
        if hex_pattern.search(message_content):
            analysis['suspicious_patterns'].append('Hex-encoded content')
            analysis['risk_score'] += 15
        
        # Check for excessive null bytes or control characters
        null_count = message_content.count('\\x00')
        if null_count > 10:
            analysis['suspicious_patterns'].append(f'Excessive null bytes ({null_count})')
            analysis['risk_score'] += 20
        
        # Check for suspicious JavaScript
        js_patterns = ['eval(', 'document.', 'window.', 'alert(']
        for pattern in js_patterns:
            if pattern in message_content:
                analysis['suspicious_patterns'].append('Suspicious JavaScript content')
                analysis['risk_score'] += 25
                break
        
        return analysis
    
    def generate_detection_report(self, scan_results: List[Dict]) -> Dict:
        """Generate comprehensive detection report"""
        report = {
            'total_files_scanned': len(scan_results),
            'threats_detected': 0,
            'critical_threats': 0,
            'high_threats': 0,
            'medium_threats': 0,
            'low_threats': 0,
            'threat_summary': [],
            'recommendations': []
        }
        
        for result in scan_results:
            if result['threats_detected']:
                report['threats_detected'] += 1
                
                # Count by threat level
                threat_level = result['threat_level']
                if threat_level == ThreatLevel.CRITICAL:
                    report['critical_threats'] += 1
                elif threat_level == ThreatLevel.HIGH:
                    report['high_threats'] += 1
                elif threat_level == ThreatLevel.MEDIUM:
                    report['medium_threats'] += 1
                else:
                    report['low_threats'] += 1
        
        # Generate recommendations
        if report['critical_threats'] > 0:
            report['recommendations'].append('CRITICAL: Isolate device and perform full security scan')
        if report['high_threats'] > 0:
            report['recommendations'].append('HIGH: Review detected threats and consider device inspection')
        if report['threats_detected'] == 0:
            report['recommendations'].append('No threats detected - continue normal monitoring')
        
        return report

def main():
    """Example usage of the iMessage threat detector"""
    detector = IMessageThreatDetector()
    
    print("🛡️ iMessage Threat Detection System")
    print("=" * 40)
    print(f"Loaded {len(detector.threat_signatures)} threat signatures")
    
    # Example: scan a suspicious file
    suspicious_data = b'\xff\xd8\xff\xe1\x00\x16Exif\x00\x00\xff\xff\xff\xff'
    result = detector.scan_file('suspicious_image.jpg', suspicious_data)
    
    print(f"\n📊 Scan Results:")
    print(f"File: {result['file_path']}")
    print(f"Threats detected: {len(result['threats_detected'])}")
    print(f"Threat level: {result['threat_level'].value}")
    
    for threat in result['threats_detected']:
        print(f"  ⚠️ {threat['description']}")

if __name__ == "__main__":
    main()
